mod error;

use std::{ffi::CString, path::Path};

pub use error::Error;
use minidl::Library;
/// Macro used to hook multiple `retour::StaticDetour`s at once
///
/// Reads a `mod` block and generating static detours from #[hook] macros.
/// #[hook] is not its own macro that gets expanded, it is read and removed by the [`hook_module`]
///
/// # `#[hook] syntax
/// Hook based off symbol
/// ```ignore
/// #[hook(<unsafe> <extern> <ABI> DETOUR_NAME, symbol = "SYMBOL_NAME")]
/// ```
/// Hook based off offset
/// ```ignore
/// #[hook(<unsafe> <extern> <ABI> DETOUR_NAME, offset = 0xDEAD_BEEF)]
/// ```
/// Examples:
/// ```ignore
/// #[hook(unsafe extern "system" MessageBoxA_Detour, symbol = "MessageBoxA")]
/// fn messageboxw_detour(hwnd: HWND, text: PCWSTR, _caption: PCWSTR, u_type: u32) -> i32 { ... }
///
/// #[hook(Add_Detour, symbol = "add")]
/// fn add(a: i32, b: i32) -> i32 { ... }
///
/// #[hook(lua_newstate_Detour, offset = 0x4321)]
/// fn add(a: i32, b: i32) -> i32 { ... }
/// ```
///
///
/// # Example
/// ```ignore
/// use retour_utils::hook_module;
///
/// #[hook_module("lua52.dll")]
/// mod lua {
///     // Creates a StaticDetour called Lua_newstate with the same function type as our function
///     // (minus abi/unsafe to work with retour crate)
///     #[hook(unsafe extern "C" Lua_newstate, symbol = "Lua_newstate")]
///     pub fn newstate(f: *mut lua_Alloc, ud: *mut std::ffi::c_void) -> *mut lua_State {
///         unsafe {
///             Lua_newstate.call(f, ud)
///         }
///     }
///
///     // == Generated by macro: ==
///     // #[hook_module] will create `MODULE_NAME`:
///     const MODULE_NAME: &str = "lua52.dll"
///     // and init_detours function
///     pub unsafe init_detours() -> crate::Result<()> {..}
///     // which will initialize all the StaticDetours generated by the macro inside this module
/// }
/// ```
pub use retour_utils_impl::hook_module;

type Result<T> = std::result::Result<T, error::Error>;

pub enum LookupData {
    Offset {
        module: &'static str,
        offset: usize,
    },
    Symbol {
        module: &'static str,
        symbol: &'static str,
    },
}

impl LookupData {
    pub const fn from_offset(module: &'static str, offset: usize) -> Self {
        Self::Offset { module, offset }
    }

    pub const fn from_symbol(module: &'static str, symbol: &'static str) -> Self {
        Self::Symbol { module, symbol }
    }

    fn get_module(&self) -> &str {
        match self {
            Self::Offset { module, .. } => module,
            Self::Symbol { module, .. } => module,
        }
    }

    fn address_from_handle(&self, handle: &Library) -> Option<*const ()> {
        match self {
            LookupData::Offset { offset, .. } => {
                Some((handle.as_ptr() as usize + offset) as *const ())
            }
            LookupData::Symbol { symbol, .. } => {
                let c_symbol = CString::new(*symbol).ok()?;
                let symbol_with_null_terminator =
                    String::from_utf8(c_symbol.into_bytes_with_nul()).ok()?;

                unsafe { handle.sym_opt(&symbol_with_null_terminator) }
            }
        }
    }
}

/// Initialize detour by passing the address of original function to `init_detour_fn`
///
/// This is called by `init_detours`, which is generated by the [`hook_module`] macro
pub unsafe fn init_detour(
    lookup_data: LookupData,
    init_detour_fn: fn(*const ()) -> retour::Result<()>,
) -> Result<()> {
    // Get handle to module (aka dll / so)
    if let Ok(handle) = Library::load(Path::new(lookup_data.get_module())) {
        let Some(addr) = lookup_data.address_from_handle(&handle) else {
            return Err(Error::ModuleNotLoaded);
        };
        init_detour_fn(addr)?;
    }

    Ok(())
}
